{"version":3,"file":"correlated-scene-graph.js","sourceRoot":"","sources":["../../../src/three-components/gltf-instance/correlated-scene-graph.ts"],"names":[],"mappings":"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","sourcesContent":["import {Group, Material, Mesh, Object3D, Texture} from 'three';\nimport {GLTF as ThreeGLTF, GLTFReference} from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport {GLTF, GLTFElement} from '../../three-components/gltf-instance/gltf-2.0.js';\n\n\n\nexport type ThreeSceneObject = Object3D|Material|Texture;\ntype ThreeSceneObjectCallback = (a: ThreeSceneObject, b: ThreeSceneObject) =>\n    void;\n\nexport type ThreeObjectSet = Set<ThreeSceneObject>;\n\nexport type GLTFElementToThreeObjectMap = Map<GLTFElement, ThreeObjectSet>;\nexport type ThreeObjectToGLTFElementHandleMap =\n    Map<ThreeSceneObject, GLTFReference>;\n\nconst $threeGLTF = Symbol('threeGLTF');\nconst $gltf = Symbol('gltf');\nconst $gltfElementMap = Symbol('gltfElementMap');\nconst $threeObjectMap = Symbol('threeObjectMap');\nconst $parallelTraverseThreeScene = Symbol('parallelTraverseThreeScene');\n\nconst $correlateOriginalThreeGLTF = Symbol('correlateOriginalThreeGLTF');\nconst $correlateCloneThreeGLTF = Symbol('correlateCloneThreeGLTF');\n\n/**\n * The Three.js GLTFLoader provides us with an in-memory representation\n * of a glTF in terms of Three.js constructs. It also provides us with a copy\n * of the deserialized glTF without any Three.js decoration, and a mapping of\n * glTF elements to their corresponding Three.js constructs.\n *\n * A CorrelatedSceneGraph exposes a synchronously available mapping of glTF\n * element references to their corresponding Three.js constructs.\n */\nexport class CorrelatedSceneGraph {\n  /**\n   * Produce a CorrelatedSceneGraph from a naturally generated Three.js GLTF.\n   * Such GLTFs are produced by Three.js' GLTFLoader, and contain cached\n   * details that expedite the correlation step.\n   *\n   * If a CorrelatedSceneGraph is provided as the second argument, re-correlates\n   * a cloned Three.js GLTF with a clone of the glTF hierarchy used to produce\n   * the upstream Three.js GLTF that the clone was created from. The result\n   * CorrelatedSceneGraph is representative of the cloned hierarchy.\n   */\n  static from(\n      threeGLTF: ThreeGLTF,\n      upstreamCorrelatedSceneGraph?: CorrelatedSceneGraph):\n      CorrelatedSceneGraph {\n    if (upstreamCorrelatedSceneGraph != null) {\n      return this[$correlateCloneThreeGLTF](\n          threeGLTF, upstreamCorrelatedSceneGraph);\n    } else {\n      return this[$correlateOriginalThreeGLTF](threeGLTF);\n    }\n  }\n\n  private static[$correlateOriginalThreeGLTF](threeGLTF: ThreeGLTF):\n      CorrelatedSceneGraph {\n    const gltf = threeGLTF.parser.json as GLTF;\n\n    const {associations} = threeGLTF.parser;\n    const gltfElementMap: GLTFElementToThreeObjectMap = new Map();\n\n    const defaultMaterial = {name: 'Default'} as Material;\n    const defaultReference = {type: 'materials', index: -1} as GLTFReference;\n\n    // NOTE: IE11 does not have Map iterator methods\n    associations.forEach((gltfElementReference, threeObject) => {\n      // Note: GLTFLoader creates a \"default\" material that has no corresponding\n      // glTF element in the case that no materials are specified in the source\n      // glTF. In this case we append a default material to allow this to be\n      // operated upon.\n      if (gltfElementReference == null) {\n        if (defaultReference.index < 0) {\n          if (gltf.materials == null) {\n            gltf.materials = [];\n          }\n          defaultReference.index = gltf.materials.length;\n          gltf.materials.push(defaultMaterial);\n        }\n        gltfElementReference = defaultReference;\n      }\n\n      const {type, index} = gltfElementReference;\n      const elementArray = gltf[type] || [];\n      const gltfElement = elementArray[index];\n\n      if (gltfElement == null) {\n        // TODO: Maybe throw here...\n        return;\n      }\n\n      let threeObjects = gltfElementMap.get(gltfElement);\n\n      if (threeObjects == null) {\n        threeObjects = new Set();\n        gltfElementMap.set(gltfElement, threeObjects);\n      }\n\n      threeObjects.add(threeObject);\n    });\n\n    return new CorrelatedSceneGraph(\n        threeGLTF, gltf, associations, gltfElementMap);\n  }\n\n  /**\n   * Transfers the association between a raw glTF and a Three.js scene graph\n   * to a clone of the Three.js scene graph, resolved as a new\n   * CorrelatedsceneGraph instance.\n   */\n  private static[$correlateCloneThreeGLTF](\n      cloneThreeGLTF: ThreeGLTF,\n      upstreamCorrelatedSceneGraph: CorrelatedSceneGraph):\n      CorrelatedSceneGraph {\n    const originalThreeGLTF = upstreamCorrelatedSceneGraph.threeGLTF;\n    const originalGLTF = upstreamCorrelatedSceneGraph.gltf;\n    const cloneGLTF: GLTF = JSON.parse(JSON.stringify(originalGLTF));\n    const cloneThreeObjectMap: ThreeObjectToGLTFElementHandleMap = new Map();\n    const cloneGLTFELementMap: GLTFElementToThreeObjectMap = new Map();\n\n    const defaultMaterial = {name: 'Default'} as Material;\n    const defaultReference = {type: 'materials', index: -1} as GLTFReference;\n\n    for (let i = 0; i < originalThreeGLTF.scenes.length; i++) {\n      this[$parallelTraverseThreeScene](\n          originalThreeGLTF.scenes[i],\n          cloneThreeGLTF.scenes[i],\n          (object: ThreeSceneObject, cloneObject: ThreeSceneObject) => {\n            let elementReference =\n                upstreamCorrelatedSceneGraph.threeObjectMap.get(object);\n\n            if (((object as Mesh).isMesh || (object as Material).isMaterial) &&\n                elementReference == null) {\n              // Checks if default material was allready addded to the gltf.\n              if (cloneGLTF.materials && cloneGLTF.materials.length) {\n                const material =\n                    cloneGLTF.materials[cloneGLTF.materials.length - 1];\n                if (material.name === 'Default') {\n                  defaultReference.index = cloneGLTF.materials.length - 1;\n                }\n              }\n\n              // Adds the defaul material if the default material was not added.\n              if (defaultReference.index < 0) {\n                if (cloneGLTF.materials == null) {\n                  cloneGLTF.materials = [];\n                }\n                defaultReference.index = cloneGLTF.materials.length;\n                cloneGLTF.materials.push(defaultMaterial);\n              }\n\n              elementReference = defaultReference;\n            }\n\n\n            if (elementReference == null) {\n              return;\n            }\n\n            const {type, index} = elementReference;\n            const cloneElement = cloneGLTF[type]![index];\n\n            cloneThreeObjectMap.set(cloneObject, {type, index});\n\n            const cloneObjects: Set<typeof cloneObject> =\n                cloneGLTFELementMap.get(cloneElement) || new Set();\n            cloneObjects.add(cloneObject);\n\n            cloneGLTFELementMap.set(cloneElement, cloneObjects);\n          });\n    }\n\n    return new CorrelatedSceneGraph(\n        cloneThreeGLTF, cloneGLTF, cloneThreeObjectMap, cloneGLTFELementMap);\n  }\n\n  /**\n   * Traverses two presumably identical Three.js scenes, and invokes a callback\n   * for each Object3D or Material encountered, including the initial scene.\n   * Adapted from\n   * https://github.com/mrdoob/three.js/blob/7c1424c5819ab622a346dd630ee4e6431388021e/examples/jsm/utils/SkeletonUtils.js#L586-L596\n   */\n  private static[$parallelTraverseThreeScene](\n      sceneOne: Group, sceneTwo: Group, callback: ThreeSceneObjectCallback) {\n    const isMesh = (object: unknown): object is Mesh => {\n      return (object as Mesh).isMesh;\n    };\n    const traverse = (a: ThreeSceneObject, b: ThreeSceneObject) => {\n      callback(a, b);\n\n      if ((a as Object3D).isObject3D) {\n        if (isMesh(a)) {\n          if (Array.isArray(a.material)) {\n            for (let i = 0; i < a.material.length; ++i) {\n              traverse(\n                  a.material[i], ((b as typeof a).material as Material[])[i]);\n            }\n          } else {\n            traverse(a.material, (b as typeof a).material as Material);\n          }\n        }\n\n        for (let i = 0; i < (a as Object3D).children.length; ++i) {\n          traverse((a as Object3D).children[i], (b as Object3D).children[i]);\n        }\n      }\n    };\n\n    traverse(sceneOne, sceneTwo);\n  }\n\n  private[$threeGLTF]: ThreeGLTF;\n  private[$gltf]: GLTF;\n  private[$gltfElementMap]: GLTFElementToThreeObjectMap;\n  private[$threeObjectMap]: ThreeObjectToGLTFElementHandleMap;\n\n  /**\n   * The source Three.js GLTF result given to us by a Three.js GLTFLoader.\n   */\n  get threeGLTF(): ThreeGLTF {\n    return this[$threeGLTF];\n  }\n\n  /**\n   * The in-memory deserialized source glTF.\n   */\n  get gltf(): GLTF {\n    return this[$gltf];\n  }\n\n  /**\n   * A Map of glTF element references to arrays of corresponding Three.js\n   * object references. Three.js objects are kept in arrays to account for\n   * cases where more than one Three.js object corresponds to a single glTF\n   * element.\n   */\n  get gltfElementMap(): GLTFElementToThreeObjectMap {\n    return this[$gltfElementMap];\n  }\n\n  /**\n   * A map of individual Three.js objects to corresponding elements in the\n   * source glTF.\n   */\n  get threeObjectMap(): ThreeObjectToGLTFElementHandleMap {\n    return this[$threeObjectMap];\n  }\n\n  constructor(\n      threeGLTF: ThreeGLTF, gltf: GLTF,\n      threeObjectMap: ThreeObjectToGLTFElementHandleMap,\n      gltfElementMap: GLTFElementToThreeObjectMap) {\n    this[$threeGLTF] = threeGLTF;\n    this[$gltf] = gltf;\n    this[$gltfElementMap] = gltfElementMap;\n    this[$threeObjectMap] = threeObjectMap;\n  }\n\n  async loadVariant(variantName: string): Promise<Set<number>> {\n    const updatedMaterials = new Set<number>();\n\n    if (!('variants' in this.threeGLTF.userData) ||\n        !('functions' in this.threeGLTF.userData) ||\n        !('selectVariant' in this.threeGLTF.userData.functions)) {\n      return updatedMaterials;\n    }\n\n    await this.threeGLTF.userData.functions.selectVariant(\n        this.threeGLTF.scene,\n        variantName,\n        true,\n        (object: Object3D,\n         _oldMaterial: Material,\n         gltfMaterialIndex: number) => {\n          updatedMaterials.add(gltfMaterialIndex);\n          const gltfElement = this.gltf.materials![gltfMaterialIndex];\n          let threeObjects = this.gltfElementMap.get(gltfElement);\n          if (threeObjects == null) {\n            threeObjects = new Set();\n            this.gltfElementMap.set(gltfElement, threeObjects);\n          }\n          threeObjects.add((object as Mesh).material as Material);\n        });\n\n    return updatedMaterials;\n  }\n}\n"]}
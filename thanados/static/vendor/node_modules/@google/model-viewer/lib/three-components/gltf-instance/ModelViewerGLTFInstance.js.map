{"version":3,"file":"ModelViewerGLTFInstance.js","sourceRoot":"","sources":["../../../src/three-components/gltf-instance/ModelViewerGLTFInstance.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {CorrelatedSceneGraph} from '@google/3dom/lib/facade/three-js/correlated-scene-graph.js';\nimport {BackSide, DoubleSide, FrontSide, Material, Mesh, MeshStandardMaterial, Object3D, Shader} from 'three';\nimport {GLTF} from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport {$clone, $prepare, $preparedGLTF, GLTFInstance, PreparedGLTF} from '../GLTFInstance.js';\nimport {Renderer} from '../Renderer.js';\nimport {alphaChunk} from '../shader-chunk/alphatest_fragment.glsl.js';\n\nconst $cloneAndPatchMaterial = Symbol('cloneAndPatchMaterial');\nconst $correlatedSceneGraph = Symbol('correlatedSceneGraph');\n\ninterface PreparedModelViewerGLTF extends PreparedGLTF {\n  [$correlatedSceneGraph]?: CorrelatedSceneGraph;\n}\n\n/**\n * This specialization of GLTFInstance collects all of the processing needed\n * to prepare a model and to clone it making special considerations for\n * <model-viewer> use cases.\n */\nexport class ModelViewerGLTFInstance extends GLTFInstance {\n  /**\n   * @override\n   */\n  protected static[$prepare](source: GLTF) {\n    const prepared = super[$prepare](source) as PreparedModelViewerGLTF;\n\n    if (prepared[$correlatedSceneGraph] == null) {\n      prepared[$correlatedSceneGraph] = CorrelatedSceneGraph.from(prepared);\n    }\n\n    const {scene} = prepared;\n\n    const meshesToDuplicate: Mesh[] = [];\n\n    scene.traverse((node: Object3D) => {\n      // Set a high renderOrder while we're here to ensure the model\n      // always renders on top of the skysphere\n      node.renderOrder = 1000;\n\n      // Three.js seems to cull some animated models incorrectly. Since we\n      // expect to view our whole scene anyway, we turn off the frustum\n      // culling optimization here.\n      node.frustumCulled = false;\n      // Animations for objects without names target their UUID instead. When\n      // objects are cloned, they get new UUIDs which the animation can't\n      // find. To fix this, we assign their UUID as their name.\n      if (!node.name) {\n        node.name = node.uuid;\n      }\n      if (!(node as Mesh).isMesh) {\n        return;\n      }\n      node.castShadow = true;\n      const mesh = node as Mesh;\n      let transparent = false;\n      const materials =\n          Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n      materials.forEach(material => {\n        if ((material as any).isMeshStandardMaterial) {\n          if (material.transparent && material.side === DoubleSide) {\n            transparent = true;\n            material.side = FrontSide;\n          }\n          Renderer.singleton.roughnessMipmapper.generateMipmaps(\n              material as MeshStandardMaterial);\n        }\n      });\n\n      if (transparent) {\n        meshesToDuplicate.push(mesh);\n      }\n    });\n\n    // We duplicate transparent, double-sided meshes and render the back face\n    // before the front face. This creates perfect triangle sorting for all\n    // convex meshes. Sorting artifacts can still appear when you can see\n    // through more than two layers of a given mesh, but this can usually be\n    // mitigated by the author splitting the mesh into mostly convex regions.\n    // The performance cost is not too great as the same shader is reused and\n    // the same number of fragments are processed; only the vertex shader is run\n    // twice. @see https://threejs.org/examples/webgl_materials_physical_transparency.html\n    for (const mesh of meshesToDuplicate) {\n      const materials =\n          Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n      const duplicateMaterials = materials.map((material) => {\n        const backMaterial = material.clone();\n        backMaterial.side = BackSide;\n        return backMaterial;\n      });\n      const duplicateMaterial = Array.isArray(mesh.material) ?\n          duplicateMaterials :\n          duplicateMaterials[0];\n      const meshBack = new Mesh(mesh.geometry, duplicateMaterial);\n      meshBack.renderOrder = -1;\n      mesh.add(meshBack);\n    }\n\n    return prepared;\n  }\n\n  get correlatedSceneGraph() {\n    return (\n        this[$preparedGLTF] as PreparedModelViewerGLTF)[$correlatedSceneGraph]!;\n  }\n\n  /**\n   * @override\n   */\n  [$clone](): PreparedGLTF {\n    const clone: PreparedModelViewerGLTF = super[$clone]();\n    const sourceUUIDToClonedMaterial = new Map<string, Material>();\n\n    clone.scene.traverse((node: any) => {\n      // Materials aren't cloned when cloning meshes; geometry\n      // and materials are copied by reference. This is necessary\n      // for the same model to be used twice with different\n      // environment maps.\n      if ((node as Mesh).isMesh) {\n        const mesh = node as Mesh;\n        if (Array.isArray(mesh.material)) {\n          mesh.material = mesh.material.map(\n              (material) => this[$cloneAndPatchMaterial](\n                  material, sourceUUIDToClonedMaterial));\n        } else if (mesh.material != null) {\n          mesh.material = this[$cloneAndPatchMaterial](\n              mesh.material, sourceUUIDToClonedMaterial);\n        }\n      }\n    });\n\n    // Cross-correlate the scene graph by relying on information in the\n    // current scene graph; without this step, relationships between the\n    // Three.js object graph and the glTF scene graph will be lost.\n    clone[$correlatedSceneGraph] =\n        CorrelatedSceneGraph.from(clone, this.correlatedSceneGraph);\n\n    return clone;\n  }\n\n  /**\n   * Creates a clone of the given material, and applies a patch to the\n   * shader program.\n   */\n  [$cloneAndPatchMaterial](\n      material: Material, sourceUUIDToClonedMaterial: Map<string, Material>) {\n    // If we already cloned this material (determined by tracking the UUID of\n    // source materials that have been cloned), then return that previously\n    // cloned instance:\n    if (sourceUUIDToClonedMaterial.has(material.uuid)) {\n      return sourceUUIDToClonedMaterial.get(material.uuid)!;\n    }\n\n    const clone = material.clone();\n\n    // This allows us to patch three's materials, on top of patches already\n    // made, for instance GLTFLoader patches SpecularGlossiness materials.\n    // Unfortunately, three's program cache differentiates SpecGloss materials\n    // via onBeforeCompile.toString(), so these two functions do the same\n    // thing but look different in order to force a proper recompile.\n    const oldOnBeforeCompile = material.onBeforeCompile;\n    clone.onBeforeCompile = (material as any).isGLTFSpecularGlossinessMaterial ?\n        (shader: Shader) => {\n          oldOnBeforeCompile(shader, undefined as any);\n          shader.fragmentShader = shader.fragmentShader.replace(\n              '#include <alphatest_fragment>', alphaChunk);\n        } :\n        (shader: Shader) => {\n          shader.fragmentShader = shader.fragmentShader.replace(\n              '#include <alphatest_fragment>', alphaChunk);\n          oldOnBeforeCompile(shader, undefined as any);\n        };\n    // This makes shadows better for non-manifold meshes\n    clone.shadowSide = FrontSide;\n    // This improves transparent rendering and can be removed whenever\n    // https://github.com/mrdoob/three.js/pull/18235 finally lands.\n    if (clone.transparent) {\n      clone.depthWrite = false;\n    }\n    // This little hack ignores alpha for opaque materials, in order to comply\n    // with the glTF spec.\n    if (!clone.alphaTest && !clone.transparent) {\n      clone.alphaTest = -0.5;\n    }\n\n    sourceUUIDToClonedMaterial.set(material.uuid, clone);\n\n    return clone;\n  }\n}"]}